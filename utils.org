* various utilities i would like to have
** list packages with install *and* upgrade status

i had this in fink.

[[http://stackoverflow.com/a/10428825/1527747][use debian-tools deb822]].  but, i need to parse the sources list, or
all the files in /var/lib/apt/lists.  and, in what order?  how does one
parse the version number to know ordering of versions?
here is the [[https://www.debian.org/doc/debian-policy/ch-controlfields.html#s-f-Version][version spec]].

#+BEGIN_SRC python
  from debian import deb822

  # get processor type (i386, amd64, etc.)

  # now, for each i in /var/lib/apt/lists/*._${PROC}_Packages, build a
  # database of what the highest level of each package might be.

  # now, for each installed package, add installed version to the
  # database.  this can be retrieved from deb822 on
  # /var/lib/dpkg/status.

  # now, for each available package, add to the database.  (actually,
  # probably done with the _Packages step above.)

  # now, for each entry in the database, output the summary.
#+END_SRC

or, i could just do a tool that would output the highest available
version for each /var/lib/apt/lists/*_${PROC}_Packages, and then diff
with output from 
: dpkg-query -W --showformat='${Package} ${Version}'

that might make more sense.  actually,
: apt list
sort of does this
: apt list 2>&1 | fgrep '[upgrad' | less
gives the upgradable packages
: apt list 2>&1 | fgrep '[' | less
gives all installed packages (upgradable or not)
: apt list 2>&1 | fgrep -v '[' | less
gives all uninstalled packages

so,
#+BEGIN_SRC python :results output
  # module subprocess: http://stackoverflow.com/a/89243/1527747
  try:    
      import sys
  except ImportError:
      print("python error: unable to import \"sys\"")
      raise
  try:
      import subprocess
  except ImportError:
      sys.stderr.write("python error: unable to import required module \"subprocess\"\n")
      sys.exit(1)
  try:
      import re
  except ImportError:
      sys.stderr.write("python error: unable to import required module \"re\"\n")
      sys.exit(1)

  def crack_instatus(status):
      installed = re.search("^.installed", status) != None
      automatic = re.search("^.[a-z]*,automatic", status) != None
      upgradeable = re.search("^.upgrade*able", status) != None
      if upgradeable:
          sre = re.search("^.upgrade*able from: ", status)
          insvers = sre.re.sub("", status).replace("]", "")
      else:
          insvers = None
      return (installed, automatic, upgradeable, insvers)

  # run
  # apt list 2>&1 | sed 'sX/[^ ]*XXg'
  try:
      al = subprocess.Popen("apt list", shell=True, stdout=subprocess.PIPE)
  except OSError:
      sys.stderr.write("unable to exec apt(8).  is it installed?\n")
      sys.exit(1)
  try:
      se = subprocess.Popen("sed 'sX/[^ ]*XXg'", shell=True,
                            stdin=al.stdout, stdout=subprocess.PIPE)
  except OSError:
      sys.stderr.write("unable to exec sed(8).  is it installed?\n")
      sys.exit(1)

  # build a database of the output
  dbase = dict()
  # update the database with 1) install status ('[' exists in $4); 2)
  # upgradeable ($2 here doesn't match $2 in dpkg-query)
  for line in se.stdout:
      sys.stderr.write(line); sys.stderr.write("\n")
      try:
          (package, availvers, processor, instatus) = line.split()
          (instatus, insauto, insupgrade, insvers) = crack_instatus(instatus)
          if insvers == None:
              insvers = availvers
          sys.stderr.write("installed {}\n".format((package, availvers, processor, instatus)))
      except ValueError:
          try:
              (package, availvers, processor) = line.split()
              instatus = False
              insauto = False
              insupgrade = False
              insvers = availvers
              sys.stderr.write("not installed {}\n".format((package, availvers, processor, instatus)))
          except ValueError:
              sys.stderr.write("continuing...\n")
              continue            # XXX presumably "Listing..."
      dbase[package] = {'instatus':instatus, 'insvers':insvers,
                        'availvers':availvers, 'desc':False,
                        'insauto':insauto, 'insupgrade':insupgrade}
      # sys.stderr.write("{} {}\n".format(package, dbase[package]))

  # run
  # dpkg-query -W --showformat='${Package} ${Version} ${Description}\n' | grep -v '^ '
  try:
      dq = subprocess.Popen("dpkg-query -W --showformat='${Package} ${Version} ${Description}\n'",
                            shell=True, stdout=subprocess.PIPE)
  except OSError:
      sys.stderr.write("unable to exec dpkg-query(1).  is it installed?\n")
      sys.exit(1)
  try:
      gr = subprocess.Popen("grep -v '^ '", shell=True,
                            stdin=dq.stdout, stdout=subprocess.PIPE)
  except OSError:
      sys.stderr.write("unable to exec grep(1).  is it installed?\n")
      sys.exit(1)

  # processing line by line: http://stackoverflow.com/a/8010133/1527747
  for line in gr.stdout:
      # sys.stderr.write(line); sys.stderr.write("\n")
      spl = line.split()
      package = spl.pop(0)
      version = spl.pop(0)
      desc = " ".join(spl)
      if not package in dbase:
          sys.stderr.write("expected to find package {} in dbase\n".format(package))
          sys.exit(2)
      if dbase[package]['insvers'] != version:
          sys.stderr.write("unexpected version {} from dpkg-query for package {}; expected {}\n".format(
              version, package, dbase[package]['insvers']))
          sys.exit(2)
      dbase[package]['desc'] = desc

  for (package, entry) in dbase.iteritems():
      print(package, entry)

#+END_SRC

#+RESULTS:


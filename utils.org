* various utilities i would like to have
** TODO list packages with install *and* upgrade status

i had this in fink.

[[http://stackoverflow.com/a/10428825/1527747][use debian-tools deb822]].  but, i need to parse the sources list, or
all the files in /var/lib/apt/lists.  and, in what order?  how does one
parse the version number to know ordering of versions?
here is the [[https://www.debian.org/doc/debian-policy/ch-controlfields.html#s-f-Version][version spec]].

#+BEGIN_SRC python
  from debian import deb822

  # get processor type (i386, amd64, etc.)

  # now, for each i in /var/lib/apt/lists/*._${PROC}_Packages, build a
  # database of what the highest level of each package might be.

  # now, for each installed package, add installed version to the
  # database.  this can be retrieved from deb822 on
  # /var/lib/dpkg/status.

  # now, for each available package, add to the database.  (actually,
  # probably done with the _Packages step above.)

  # now, for each entry in the database, output the summary.
#+END_SRC

or, i could just do a tool that would output the highest available
version for each /var/lib/apt/lists/*_${PROC}_Packages, and then diff
with output from 
: dpkg-query -W --showformat='${Package} ${Version}'

that might make more sense.  actually,
: apt list
sort of does this
: apt list 2>&1 | fgrep '[upgrad' | less
gives the upgradable packages
: apt list 2>&1 | fgrep '[' | less
gives all installed packages (upgradable or not)
: apt list 2>&1 | fgrep -v '[' | less
gives all uninstalled packages

so,
#+BEGIN_SRC python :results output :tangle apt-list :shebang "#!/usr/bin/env python"
  def mport(modstring):
      """try to import a module named MODSTRING, printing an error message and aborting on failure.  (note that module sys must already be imported.)"""
      try:
          eval(compile("import {}".format(modstring), "foo.c", "single"), globals())
      except ImportError:
          sys.stderr.write("python error: unable to import required module \"{}\"\n".format(modstring))
          sys.exit(1)

  def popen(cmd, stdin=None, stdout=None, stderr=None):
      """open a pipe, complaining in the event of a failure"""
      # PATTERN to ignore spaces inside quotes:
      # http://stackoverflow.com/q/2785755/1527747
      PATTERN = re.compile(r'''((?:[^ "']|"[^"]*"|'[^']*')+)''')
      # now, get rid of any stray quotes.  faster way?
      list = PATTERN.split(cmd)[1::2]
      dmc = []
      for i in list:
          dmc.append(re.sub('[\'"]', '', i))
      try:
          po = subprocess.Popen(dmc, stdin=stdin, stdout=stdout, stderr=stderr)
      except OSError:
          sys.stderr.write("unable to exec {}.  is it installed?\n".format(cmd.split()[0]))
          sys.exit(1)
      return po

  def crack_instatus(slist):
      # sys.stderr.write("crack_instatus({})\n".format(slist))
      status = slist.pop(0)
      installed = re.search("^installed", status) != None
      automatic = re.search("^[a-z]*,automatic", status) != None
      upgradeable = re.search("^upgrade*able", status) != None
      if upgradeable:
          slist.pop(0)                # "from:"
          insvers = slist.pop(0)
      else:
          insvers = None
      return (installed, automatic, upgradeable, insvers)

  #
  try:    
      import sys
  except ImportError:
      print("python error: unable to import \"sys\"")
      raise

  # module subprocess: http://stackoverflow.com/a/89243/1527747
  mport("subprocess")
  mport("re")

  # run
  # apt-cache dumpavail
  ac = popen("apt-cache dumpavail", stdout=subprocess.PIPE)
  package = None
  desc = None
  descriptions = dict()
  for line in ac.stdout:
      # sys.stderr.write("ac: {}\n".format(line))
      if line == "\n":            # read in one complete
          if package != None or desc != None:
              if package == None:
                  pass            # XXX
              elif desc == None:
                  pass            # XXX
              descriptions[package] = desc
              package = None
              desc = None
          continue
      spl = line.split()
      verb = spl.pop(0)
      if verb == "Package:":
          package = spl.pop(0)
      elif verb == "Description:":
          desc = " ".join(spl)
  if package != None or desc != None:
      if package == None:
          pass            # XXX
      elif desc == None:
          pass            # XXX
      descriptions[package] = desc
      package = None
      desc = None

  # run
  # apt list 2>&1 | sed 'sX/[^ ]*XXg'
  al = popen("apt list", stdout=subprocess.PIPE)
  se = popen("sed 'sX/[^ ]*XXg'", stdin=al.stdout, stdout=subprocess.PIPE)

  # build a database of the output
  dbase = dict()
  # update the database with 1) install status ('[' exists in $4); 2)
  # upgradeable ($2 here doesn't match $2 in dpkg-query)
  # processing line by line: http://stackoverflow.com/a/8010133/1527747
  for line in se.stdout:
      if line == "Listing...\n":
          continue
      # sys.stderr.write(line); sys.stderr.write("\n")
      spl = re.split('[][ ]+', line)
      package = spl.pop(0)
      availvers = spl.pop(0)
      processor = spl.pop(0)
      if len(spl) > 0:
          # sys.stderr.write("{}\n".format(spl))
          spl.pop()          # get rid of trailing newline
          (instatus, insauto, insupgrade, insvers) = crack_instatus(spl)
          if insvers == None:
              insvers = availvers
      else:
          instatus = False
          insauto = False
          insupgrade = False
          insvers = availvers
      if not package in descriptions:
          # sys.stderr.write("don't have description (from apt-cache(8)) for package {}\n", package)
          sys.exit(4)
      dbase[package] = {'instatus':instatus, 'insvers':insvers,
                        'availvers':availvers, 'desc':descriptions[package],
                        'insauto':insauto, 'insupgrade':insupgrade}
      # sys.stderr.write("{} {}\n".format(package, dbase[package]))

  packages = dbase.keys()
  packages.sort()
  for package in packages:
      entry = dbase[package]
      if entry['insupgrade']:
          prefix = "I       "
          upgrade = " ({})".format(entry['availvers'])
      elif entry['instatus']:
          prefix = "i       "
          upgrade = ""
      else:
          prefix = "        "
          upgrade = ""
      try:
          print("{}{} {}{}:\t{}".format(prefix, package, entry['insvers'],
                                        upgrade, entry['desc']))
      except IOError:
          sys.exit(0)         # pipeline shutdown
#+END_SRC

#+RESULTS:
